#' Count Overlap of ATAC-seq Fragments
#'
#' Count Overlap of ATAC-seq Fragments
#'
#' @param file Filename of the file for ATAC-seq fragments.
#' The file must be block gzipped (using the \code{bgzip} command)
#' and accompanied with the index file (made using the \code{tabix} command).
#' The uncompressed file must be a tab delimited file,
#' where each row represents one fragment.
#' The first four columns are chromosome name, start position, end position,
#' and barcode (i.e., name) of the cell including the fragment.
#' The remaining columns are ignored.
#' See vignette for details.
#' @param targetregions GRanges object for the regions where overlaps are counted.
#' Usually all of the autosomes.
#' @param excluderegions GRanges object for the regions to be excluded.
#' Simple repeats in the genome should be listed here,
#' because repeats can cause false overlaps.
#' A fragment is discarded if its 5' or 3' is located in \code{excluderegions}.
#' @param targetbarcodes Character vector for the barcodes of cells to be analyzed,
#' such as those passing quality control.
#' If \code{NULL}, all barcodes in the input file are analyzed.
#' @param Tn5offset Numeric vector of length two.
#' The enzyme for ATAC-seq is a homodimer of Tn5.
#' The transposition sites of two Tn5 proteins are 9 bp apart,
#' and the (representative) site of accessibility is in between.
#' If the start and end position of your input file is taken from BAM file,
#' set the paramater to \code{c(4, -5)} to adjust the offset.
#' Alternatively, values such as \code{c(0, -9)} could generate similar results;
#' what matters the most is the difference between the two numbers.
#' The fragments.tsv.gz file generated by 10x Cell Ranger already adjusts the shift
#' but is recorded as a BED file. In this case, use \code{c(1, 0)} (default value).
#' If unsure, try \code{"guess"},
#' in which case the program returns a guess.
#' @return A tibble with each row corresponding to a cell.
#' For each cell, its barcode, the total count of the fragments \code{nfrag},
#' and the count distinguished by overlap depth are given.
#'
#' @importFrom dplyr arrange desc distinct group_by lag mutate n rename summarize ungroup
#' @importFrom GenomicRanges findOverlaps makeGRangesFromDataFrame
#' @importFrom Rsamtools scanTabix TabixFile
#' @importFrom utils read.csv setTxtProgressBar txtProgressBar
#' @export
fragmentoverlapcount = function (file,
                                 targetregions,
                                 excluderegions = NULL,
                                 targetbarcodes = NULL,
                                 Tn5offset = c(1, 0)) {
  sumoverlaplist = list()
  tbx = TabixFile(file = file)
  pb = txtProgressBar(max = length(targetregions), style = 3)
  for (i in 1:length(targetregions)) {

    # Load fragments.
    res = scanTabix(tbx, param = targetregions[i])
    frags = read.csv(textConnection(res[[1]]),
                     sep = "\t",
                     header = FALSE)
    frags = frags[, 1:4]
    colnames(frags) = c("chr", "start", "end", "BC")

    if (! is.null(targetbarcodes)) {
      frags = frags[frags$BC %in% targetbarcodes, ]
    }

    # Discard "semi-duplicate" fragments;
    # Hypothesized Tn5 transposition only at one strand.
    frags = frags %>%
      group_by(BC) %>%
      # Between chrX:100-200 and chrX:100-300, only retain first
      arrange(start, end) %>%
      distinct(start, .keep_all = TRUE) %>%
      # Between chrX:100-300 and chrX:200-300, only retain last
      arrange(desc(end), desc(start)) %>%
      distinct(end, .keep_all = TRUE) %>%
      ungroup() %>%
      arrange(start, end, BC)

    # Discard fragment if 5' or 3' is located in excluderegions.
    if (! is.null(excluderegions)) {
      query = makeGRangesFromDataFrame(
        data.frame(
          seqnames = frags$chr,
          start    = frags$start,
          end      = frags$start))
      x = is.na(findOverlaps(query, excluderegions, select = "first"))
      query = makeGRangesFromDataFrame(
        data.frame(
          seqnames = frags$chr,
          start    = frags$end,
          end      = frags$end))
      x = x & is.na(findOverlaps(query, excluderegions, select = "first"))
      frags = frags[x, ]
    }

    # Adjust Tn5 site offset
    if (identical(Tn5offset, "guess")) {
      x = frags %>%
        group_by(BC) %>%
        mutate(overlap = (lag(end) - start + 1)) %>%
        ungroup()
      x = x$overlap
      x = x[abs(x) <= 18]
      if (length(x) < 20) {
        stop('Datasize is too small for guessing Tn5offset.')
      }
      x = table(x)
      x = as.numeric(names(x)[which.max(x)])
      x = c(0, -x)
      x = x - round(mean(x))
      return(x)
    } else {
      frags$start = frags$start + Tn5offset[1]
      frags$end   = frags$end   + Tn5offset[2]
    }

    # Count overlap at 5' end of each fragment.
    frags = frags %>%
      group_by(BC) %>%
      mutate(overlapcount = .overlapwithprecedingcount(start, end, TRUE)) %>%
      ungroup()

    # Summarize per BC.
    fragsbyBC = frags %>%
      group_by(BC) %>%
      summarize(nfrags = n(),
                depth1 = sum(overlapcount == 0),
                depth2 = sum(overlapcount == 1),
                depth3 = sum(overlapcount == 2),
                depth4 = sum(overlapcount == 3),
                depth5 = sum(overlapcount == 4),
                depth6 = sum(overlapcount == 5))

    sumoverlaplist = c(sumoverlaplist, list(fragsbyBC))
    setTxtProgressBar(pb, i)
  }
  close(pb)

  sumoverlap =
    do.call(rbind, sumoverlaplist) %>%
    group_by(BC) %>%
    summarize(nfrags = sum(nfrags),
              depth1 = sum(depth1),
              depth2 = sum(depth2),
              depth3 = sum(depth3),
              depth4 = sum(depth4),
              depth5 = sum(depth5),
              depth6 = sum(depth6))
  sumoverlap = sumoverlap %>%
    rename(barcode = BC)
  return(sumoverlap)
}

# A utility function.
# The fragments must be sorted by start, end.
.overlapwithprecedingcount =
  function (start, end, include) {
    ct = rep(NA, length(start))
    if (length(include) == 1) {
      include = rep(include, length(start))
    }
    unfinishedends = c()
    for (i in 1:length(start)) {
      if (!is.na(include[i]) & include[i]) {
        unfinishedends = unfinishedends[unfinishedends >= start[i]]
        ct[i] = length(unfinishedends)
        unfinishedends = c(unfinishedends, end[i])
      }
    }
    return(ct)
  }

#' Infer Ploidy from ATAC-seq Fragment Overlap
#'
#' @param fragmentoverlap Frequency of fragment overlap in each cell
#' computed by the function \code{fragmentoverlapcount}.
#' @param levels Possible values of ploidy. For example,
#' \code{c(2, 4)} if the cells can be diploids or tetraploids.
#' The values must be larger than one.
#' @return A data.frame with each row corresponding to a cell.
#' For each cell, its barcode, ploidy inferred by moment method,
#' and ploidy inferred by EM algorithm of mixture are given.
#'
#' @importFrom matrixStats rowMins
#' @importFrom mixtools multmixEM
#' @export
ploidy = function (fragmentoverlap,
                   levels) {
  if (min(levels) <= 1) {
    stop('Error: values of levels must be larger than one.')
  }

  ### MOMENT BASED METHOD
  # We model the overlapping of fragments by binomial distribution:
  # ------------------------------------------------------------
  # binomial distribution   | overlap of a fragment  | parameter
  # ------------------------------------------------------------
  # one observation         | one fragment           |
  # number of trials (size) | ploidy                 | p
  # number of success       | depth of overlap       |
  # probability of success  | probability of overlap | s
  # ------------------------------------------------------------
  # Under a predetermined p, for each cell, we estimate s based on
  # the overlap depth observed in the fragments belonging to the cell.
  # Since we cannot properly count observations with zero success,
  # we model as truncated binomial distribution.
  # We use the moment method in Paul R. Rider (1955).
  smat =
    do.call(
      cbind,
      lapply(
        levels,
        function (p) {
          x = as.matrix(fragmentoverlap[, -(1:2)])
          if (p < ncol(x)) {
            x = cbind(x[, 1:(p-1)], rowSums(x[, p:ncol(x)]))
          }
          T0 = x %*% rep(1, ncol(x))
          T1 = x %*% seq(1, ncol(x))
          T2 = x %*% (seq(1, ncol(x))^2)
          s = (T2 - T1) / ((p - 1) * T1)
          return(s)
        }))
  # We seek s that is concordant across all cells.
  # In each cell, p is allowed to take any value from levels.
  smat = log10(smat)
  scandidates = sort(as.numeric(smat))
  scandidatespenalty =
    as.numeric(
      lapply(
        scandidates,
        function (s) {
          sum(matrixStats::rowMins(abs(smat - s)))
        }))
  soptimal = scandidates[which.min(scandidatespenalty)]
  # Adopting the probability soptimal,
  # infer ploidy of each cell.
  p.moment = apply(
    abs(smat - soptimal),
    1,
    which.min)
  p.moment = levels[p.moment]

  ### EM ALGORITHM FOR MIXTURES
  # We superficially (and possibly robustly) model
  # as mixtures of multinomial distributions
  sumoverlapsubmatrix =
    as.matrix(fragmentoverlap[, 4:6])
  set.seed(100)
  em.out = multmixEM(
    y = sumoverlapsubmatrix,
    k = length(levels))
  p.em = apply(em.out$posterior, 1, which.max)
  # EM is simple clustering and unaware of the labeling in levels.
  # We transfer the labeling of p.moment to p.em.
  x = as.matrix(table(p.em, p.moment))
  x = x / rowSums(x)
  newlabels = rep(NA, length(levels))
  for (i in 1:length(levels)) {
    inds = which(x == max(x), arr.ind = TRUE)
    newlabels[ as.numeric(rownames(x)[inds[1]]) ] = colnames(x)[inds[2]]
    x = x[-c(inds[1]), -c(inds[2]), drop = FALSE]
  }
  newlabels = as.numeric(newlabels)
  p.em = newlabels[p.em]

  return(data.frame(
    barcode = fragmentoverlap$barcode,
    ploidy.moment = p.moment,
    ploidy.em = p.em))
}
